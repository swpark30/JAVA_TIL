# Java_TIL_Day_14 (멀티 스레드, 람다식)



- 목차
  - 12장 멀티 스레드
    - 개념
    - 메인 스레드
    - 작업 스레드 생성과 실행





## 12장 멀티 스레드



### 개념

- #### 프로세스(process)

  - 실행 중인 하나의 프로그램(애플리케이션)
  - 하나의 프로그램이 다중 프로세스를 만들기도 함
    - ex) 크롬 브라우저를 두 개 실행하면 두 개의 프로세스 생성

  

- #### 멀티 태스킹(multi tasking)

  - 두 가지 이상의 작업을 동시에 처리하는 것
  - 운영체제는 CPU 및 메모리 자원을 프로세스마다 적절히 할당해 주고
    병렬로 실행시킴
    - ex) 워드 문서 작업하면서 윈도우 미디어 플레이어로 음악을 들음
  - 멀티 프로세스
    - 독립적으로 프로그램들을 실행하고 여러 가지 작업 처리
  - 멀티 스레드
    - 한 개의 프로그램을 실행하고 내부적으로 여러 가지 작업 처리



### 메인 스레드

- 모든 자바 프로그램은 메인 스레드가 main() 메소드를 실행하며 시작
- main() 메소드의 첫 코드부터 아래로 순차적으로 실행
- 실행 조건
  - 마지막 코드 실행
  - return 문을 만나면 종료
- main 스레드는 작업 스레드들을 만들어 병렬로 코드를 실행
  - 멀티 스레드 생성해 멀티 태스킹 수행
- 스레드 종료
  - 싱글 스레드
    - 메인 스레드가 종료되면 프로세스도 종료
  - 멀티 스레드
    - 실행 중인 스레드가 하나라도 있으면 프로세스 미 종료
    - 몇 개의 작업을 병렬로 실행할지 결정하는 것이 선행되어야 함



### 작업 스레드 생성과 실행

- 생성 방법 2가지

  1. Thread 클래스로부터 직접 생성
     - Runnable 인터페이스 사용(구현)
     
     - Runnable 인터페이스를 매개값으로 갖는 생성자 호출
     
       ```java
       class Task implements Runnable{
           public void run(){
               스레드가 실행할 코드
           }
       }
       Runnable task = new Task();
       Thread thread = new Thread(Runnable target : task);
       // 코드 절약하기 위해 Thread 생성자를 호출할 때 Runnable 익명 객체를 매개값으로 사용 가능
       
       Thread thread = new Thread(new Runnable(){
           스레드가 실행할 코드
       });
       ```
     
     - Runnable 인터페이스
     
       - run() 메소드 하나만 정의되어 있음
     
       - Runnable은 작업 내용을 가지고 있는 객체이지 실제 스레드 아님
     
       - Runnable 구현 생성한 후 이것을 매개값으로 해서
          Thread 생성자를 호출하면 비로소 작업 스레드 생성
     
         
     
  2. Thread 하위 클래스로부터 생성
     - Thread 클래스 상속
     
     - Thread 클래스 상속 후 run 메소드 재정의해서 스레드가 실행할 코드 작성
     
       ```java
       public class WorkerThread extends Thread(){
           // run 메소드 오버라이딩
       }
       ```
     
       

- 실행 방법

  - 작업 스레드는 생성되는 즉시 실행되는 것이 아니라 start()메소드를 호출해야만 실행
  
    ```java
    thread.start()
    ```
  
  - start() 메소드가 호출되면 작업 스레드는 매개값으로 받은 Runnable run() 메소드를 실행하면서 자신의 작업을 처리



- #### 스레드 이름

  - 메인 스레드 이름 : main

  - 작업 스레드 이름 (자동 설정) : Thread-n
    
    ```java
    thread.getName(); // 스레드 이름 반환
    ```
    
  - 작업 스레드 이름 변경
    
    ```java
    thread.setName("스레드 이름");
    ```
    
  - 코드 실행하는 현재 스레드 객체 참조 얻기
    
    ```java
    Thread thread = Thread.currentThread();
    ```
    
    

- #### 스레드 우선 순위

  - 동시성과 병렬성
  
    - 동시성
      - 멀티 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질
    - 병렬성
      - 멀디 작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질
  
    
  
  - 코어
  
    - CPU 칩에서 물리적으로 연산하는 유닛 개수
    - 입력된 명령어를 계산하고 해석하는 단위
  
    
  
  - 스레드의 개수가 코어의 수보다 많을 경우
  
    - 스레드를 어떤 순서로 동시적으로 실행할 것인가 결정
      - 스레드 스케쥴링
    - 스케쥴링에 의해 스레드들은 번갈아 가면 run() 메소드 조금씩 실행
  
    
  
  - 자바의 스레드 스케쥴링
    
    - 우선 순위 방식(코드로 제어 가능)
      - 우선 순위가 높은 스레드가 실행 상태를 더 많이 가지도록 스케쥴링
      
      - 우선 순위는 1~10까지 부여되고 1이 가장 낮고 10이 가장 높은 순위이다.
      
      - 순위를 부여하지 않으면 모든 스레드들은 기본적으로 5의 순위를 할당받는다.
      
      - 순위를 변경하고 싶다면 아래 메소드를 이용
      
        ```java
        thread.setPriority(우선순위);
        thread.setPriority(Thread.MAX_PRIORITY);
        thread.setPriority(Thread.MIN_PRIORITY);
        ```
      
    - 순환 할당 방식(코드로 제어 불가)
      - 시간 할당량(Time Slice)을 정해서 하나의 스레드를 정해진 시간만큼 실행
      - 자바 가상 기계에 의해서 정해지기 때문에 코드로 제어불가



- #### 스레드 동기화

  - 공유 객체를 사용할 때 주의할점
    - 멀티 스레드가 하나의 객체를 공유해서 생기는 오류

  - 동기화 메소드 및 동기화 블록
    - 단 하나의 스레드만 실행할 수 있는 메소드 또는 블록

    - 다른 스레드는 메소드 또는 블록이 실행이 끝날 때까지 대기

    - 동기화 메소드 : synchronized 키워드 붙임

      ```java
      public synchronized void method(){
          임계 영역; // 단 하나의 스레드만 실행
      }
      ```

  - 임계영역
    - 멀티 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역
    - 자바에서는 임계 영역을 지정하기 위해 동기화 메소드와 동기화 블록 제공
    - 스레드가 객체 내부의 동기화 메소드 또는 블록에 들어가면
      즉시 객체에 잠금을 걸어 다른 스레드가 임계 영역 코드를 실행하지 못하게 함

  - 동기화 블록

    ```java
    public void method(){
        //여러 스레드가 실행 가능 영역
        synchronized (공유객체){
            임계 영역 // 단 하나의 스레드만 실행
        }
        
        // 여러 스레드가 실행 가능 영역
        
    }
    ```

    

  

- #### 스레드 상태

  - 스레드의 일반적인 상태
  - 스레드에서 일시 정지 상태 도입한 경우
    - 실행 상태에서 실행 대기 상태로 가지 않고 일시 정지 상태로 가기도 함
  - NEW 상태 (객체 생성)
  - RUNNABLE 상태
    - 실행 대기 상태

  

- #### 스레드 상태 제어

  - 실행 중인 스래드의 상태를 변경하는 것
  
  - sleep()
    - 주어진 시간 동안 일시 정지 상태가 되고, 다시 실행 대기 상태로 돌아간다.
  
  - yield()
    - 실행 대기 상태로 돌아가고 동일한 우선순위 또는 높은 우선순위를 갖는 다른 스레드가 실행 기회를 가질 수 있도록 해준다.
  
  - join()
    - 다른 스레드의 종료를 기다린다.
  
  - wait(), notify(), notifyAll()
    - 스레드 간 협업
    - 자신의 작업이 끝나면 상대방 스레드를 일시 정지 상태에서 풀어주고, 자신은 일시정지 상태로 만드는 것
    - 공유 객체는 두 스레드가 작업할 내용을 각각 동기화 메소드로 구분해 놓는다.
  
  - stop 플래그
  
    - 사용 중이던 자원들이 불안전한 상태로 남겨지기 때문에 스레드를 즉시 종료시키는 stop() 메소드는 deprecated 되었다.
  
    - 스레드는 run() 메소드가 끝나면 자동적으로 종료되므로, run() 메소드가 정상적으로 종료되도록 유도하는 것이 최선의 방법이다.
  
      ``` java
      public void run() {
          while(!stop) {
              스레드가 반복 실행하는 코드;
          }
          스레드가 사용한 자원 정리
      }
      ```
  
    - 위 코드처럼 while문으로 유도를 한다.
  
  - interrupt()
  
    - 스레드가 일시 정지 상태에 있을 때 InterruptException 예외를 발생시키는 역할을 한다.
    - 스레드의 run() 메소드에 try-catch문을 넣어서 while문을 빠져나오게 만들어 정상 종료하게 만든다.
    - 이 메소드가 실행되면 즉시 예외가 발생하지 않고, 스레드가 일시 정지 상태가 되면 예외가 발생한다는 것이다.
      - 일시정지가 되지 않으면 이 메소드 호출은 의미가 없어진다.



### 데몬 스레드

- 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드
- 스레드를 데몬으로 만드는 방법
  - 데몬이 될 스레드의 setDaemon(true) 메소드를 호출해주면 된다.
  - start() 메소드 호출 전에 setDaemon을 호출해줘야 한다.



### 스레드 그룹 

- 관련된 스레드를 묶어서 관리할 목적으로 이용 

- JVM이 실행되면 system 스레드 그룹을 만들고, JVM 운영에 필요한 스레드들을 생성해서 system 스레드 그룹에 포함시킨다.

- 스레드는 반드시 하나의 스레드 그룹에 포함된다.

- 우리가 생성하는 작업 스레드는 대부분 main 스레드가 생성한다.

- 스레드 그룹 이름 얻기

  ``` java
  ThreadGroup group = Thread.currentThread().getThreadGroup();
  String groupName = group.getName();
  
  // 모든 스레드 정보 얻기
  Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();
  // 키는 스레드 객체, 값은 스레드의 생태 기록들을 갖는 배열
  ```

- 스레드 그룹 생성

  ``` java
  ThreadGroup tg = new ThreadGroup(String name);
  ThreadGroup tg = new ThreadGroup(ThreadGroup parent, String name); // 부모 그룹을 매개값으로 줄 수 있다.
  ```

- 스레드 그룹 일괄 interrupt()

  - 그룹 내에 포함된 모든 스레드들을 일괄 interrupt할 수 있다.
  - 개별 스레드에서 발생하는 예외 처리는 하지 않으므로 안전한 종료를 위해서는 개별 스레드에서 예외 처리를 해야 한다.



### 스레드풀(ThreadPool)

- 갑작스런 병렬 작업의 폭증으로 인한 스레드의 폭증을 막으려면 스레드풀을 사용해야 한다.

- 스레드풀은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리한다.

- Executors 클래스의 다양한 정적 메소드를 이용해서 ExecutorService 구현 객체를 만들 수 있는데, 이것이 바로 스레드풀이다.

- 스레드풀 생성

  - ExecutorService 구현 객체를 얻는 코드

  ```java
  ExecutorService executorService = Executors.newCachedThreadPool();
  ```

  - CPU 코어의 수만큼 최대 스레드를 사용하는 스레드풀 생성

  ```java
  ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors);
  ```

  - 코어 스레드 개수와 최대 스레드 개수를 설정하고 싶다면 직접 ThreadPoolExecutor 객체를 생성하면 된다.

- 스레드풀 종료

  ```java
  executorService.shutdown(); // 남아있는 작업을 마무리하고 스레드풀을 종료
  executorService.shutdownNow(); // 남아있는 작업과는 상관없이 강제로 종료
  ```

- 작업 생성

  - 하나의 작업은 Runnable 또는 Callable 구현 클래스로 표현한다.
  - 차이점은 작업 처리 완료 후 ㅈ리턴값이 있느냐 없느냐이다.
  - 스레드풀의 스레드는 작업 큐에서 Runnable 또는 Callable 객체를 가져와 run()과 call() 메소드를 실행한다.

- 작업 처리 요청

  - ExecutorService의 작업 큐에 Runnable 또는 Callable 객체를 넣는 행위를 말한다.
  - execute()
    - Runnable을 작업 큐에 저장
    - 작업 처리 결과를 받지 못한다.
    - 작업 처리 도중 예외가 발생하면 스레드가 종료되고 해당 스레드는 스레드풀에서 제거된다.
  - submit()
    -  Runnable 또는 Callable을 작업 큐에 저장
    - 리턴된 Future를 통해 작업 처리 결과를 얻을 수 있다.
    - 작업 처리 도중 예외가 발생하더라도 스레드는 종료되지 않고 다음 작업을 위해 재사용된다.
  - 가급적 스레드의 생성 오버헤더를 줄이기 위해서 submit()을 사용하는 것이 좋다.

- #### 블로킹 방식의 작업 완료 통보

  - submit()의 리턴인 Future 객체는 작업 결과가 아니라 작업이 완료될 때까지 기다렸다가(지연했다가 = 블로킹되었다가) 최종 결과를 얻는데 사용된다.

  - Future를 지연 완료 객체라고 한다.

  - Future의 get() 메소드를 호출하면 스레드가 작업을 완료할 때까지 블로킹되었다가 작업을 완료하면 처리 결과를 리턴한다.

  - 리턴값이 없는 작업 완료 통보

    - 결과값이 없는 작업 처리 요청은 submit(Runnable task) 메소드를 이용한다.

    - 결과값이 없음에도  Future 객체를 리턴하는데, 스레드가 작업 처리를 정상적으로 완료했는지 예외가 발생했는지 확인하기 위해서이다.

      ```java
      Future future = executorService.submit(task);
      ```

  - 리턴값이 있는 작업 완료 통보

    - 스레드가 작업을 완료한 후에 애플리케이션이 처리 결과를 얻어야 된다면 작업 객체를 Callable로 생성하면 된다.

    - 제네릭 타입 파리미터 T는 call() 메소드가 리턴하는 타입이 되도록 한다.

      ```java
      Callable<T> task = new Callable<T>() {
          @Override
          publice T call() throws Exception {
              // 스레드가 처리할 작업 내용
              return T;
          }
      }
      ```

  - 작업 처리 결과를 외부 객체에 저장

    - 스레드가 작업 처리를 완료하고 외부 Result 객체에 작업 결과를 저장하면, 애플리케이션이 Result 객체를 사용해서 어떤 작업을 진행할 수 있을 것이다.

    - 대개 Result 객체는 공유 객체가 되어, 2개 이상의 스레드 작업을 취합할 목적으로 이용된다.

      ```java
      Result result = ...;
      Runnable task = new Task(result);
      Future<Result> future = executorService.submit(task, result);
      result = future.get();
      ```

  - 작업 완료 순으로 통보

    - 작업의 양과 스레드 스케줄링에 따라서 먼저 요청한 작업이 나중에 완료되는 경우도 발생한다.
    - CompletionService
      - 스레드풀에서 작업 처리가 완료된 것만 통보받는 방법
      - 처리 완료된 작업을 가져오는 poll()과 take()메소드가 있다.

- #### 콜백  방식의 작업 완료 통보

  - 콜백이란
    - 애플리케이션이 스레드에게 작업 처리를 요청한 후, 스레드가 작업을 완료하면 특정 메소드를 자동 실행하는 기법을 말한다.
    - 이때 자동 실행되는 메소드를 콜백 메소드라고 한다.
    - 자동적으로 콜백 메소드가 실행되어 결과를 알 수 있다.
  - 블로킹 방식은 작업 처리를 요청한 후 작업이 완료될 때까지 블로킹되지만, 콜백 방식은 작업 처리를 요청한 후 결과를 기다릴 필요 없이 다른 기능을 수행할 수 있다.
  - CompletionHandler를 이용해서 콜백 객체를 만든다.
    - completed()
      - 작업을 정상 처리 완료했을 때 호출되는 콜백 메소드
    - failed()
      - 작업 처리 도중 예외가 발생했을 때 호출되는 콜백 메소드

