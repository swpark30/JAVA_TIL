# Java_TIL_Day_17 컬렉션 프레임워크



- 목차

  - 15장 컬렉션 프레임워크
    - 컬렉션이란?
    - 프레임워크란?
    - 컬렉션 프레임워크
    - 컬렉션 프레임워크의 주요 인터페이스
      - List(인터페이스)컬렉션
      - Set 컬렉션
      - Map 컬렉션
      - Collections 클래스 활용



## 15장 컬렉션 프레임워크




### 컬렉션이란?

- 사전적 의미로 요소(객체)를 수집해 저장하는것
- 자바에서는 객체를 수집해서 저장하는 역할



### 프레임워크란?

- 표준화, 정형화된 체계적인 프로그래밍 방식

- 미리 정해진 방식대로 프로그램을 작성

  - 누가 작성하든 프로그램이 표준화되기 때문에 프로그램 유지보수하기 쉬움

    

### 컬렉션 프레임워크

- 컬렉션을 다루기 위한 표준화된 프로그래밍 방식

  - 많은 양의 데이터와 객체들을 효율적으로 추가, 삭제, 검색 등을 할 수 있도록 제공되는 컬렉션 라이브러리
  - 인터페이스를 통해서 정형화된 방법으로 다양한 컬렉션 클래스 이용

- 사용이유

  - 배열의 문제점을 해결하고 객체들을 효율적으로 추가, 삭제, 검색 등을 할 수 있도록 하기 위해서 사용한다

    

- 배열의 문제점

  - 생성시 크기 고정되고 사용 시 크기 변경불가
    - 불특정 다수의 객체를 저장하기에는 문제가 있다

  - 객체를 삭제했을 때 해당 인덱스가 빈 상태로 있다
    - 새로운 객체를 저장하려면 어디 인덱스가 비었는지 확인하는 코드가 필요해서 불편하다.

  



### 컬렉션 프레임워크의 주요 인터페이스



### List(인터페이스)컬렉션

- #### 특징

  - 순서가 있는 데이터의 집합 (객체를 일렬로 늘어놓은 구조)

  - 인덱스로 관리

  - 객체 자체를 저장하는 것이 아니라 객체의 번지를 참조한다.

  - 중복해서 객체 저장 가능

    

- #### 구현 클래스

  - **ArrayList**

    - 크기가 가변적으로 변하는 선형 리스트

    - 배열과 유사

      - 순차 리스트, 인덱스 사용

    - 배열과의 차이

      - 객체 추가 가능
      - 저장 용량 초과 시 자동으로 저장 용량 증가
      - 기본 10개
      - 처음부터 크게 설정 가능

      ```java
      //제네릭을 사용하지 않을 경우 // 자바 4 이전
      List list = new ArrayList();
      list.add("hello");
      String str = (String)list.get(0);
      
      //제네릭을 사용할 경우
      List<E> list = new ArrayList<E>();
      ```

    - 객체 추가

      - 인덱스 0부터 차례로 저장된다

    - 객체 제거

      - 제거된 객체의 바로 뒤 인덱스부터 앞으로 하나씩 당겨진다.

        - 빈번한 객체 삽입과 삭제시 사용하는걸 자제해야한다.
      - 빈번하게 일어나면 LinkedList를 사용하는 것이 좋다.
      
    - Arrays.asList(T...a) 메소드
  
      - 고정된 객체들로 구성된 List를 생성할 때 사용
  
        ```java
        List<String> list1 = Arrays.asList("홍길동", "신용권", "감자바");
        for(String name : list1) {
            System.out.println(name);
        }
        ```

    

  - **Vector**

    - ArrayList와 동일한 내부구조
  
      ```java
      List<E> list = new Vector<E>();
      ```
  
    - ArrayList와 다른점
  
      - Vector는 동기화된 메소드로 구성되어 있기 때문에 멀티스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.
  
      - 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다. (스레드 안전)
  
        
  
  - **LinkedList**
  
    - ArrayList와 사용 방법은 동일하지만 내부 구조가 다르다
  
    - ArrayList는 내부 배열에 객체를 저장해서 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼 관리
  
    - 특정 인덱스의 객체를 제거하거나 삽입할때 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다. 
  
    - 만일 중간에서 제거 하면 제거한 부분 앞뒤의 체인이 서로 연결되어 변경된다.
  
      ```java
      List<E> list = new LinkedList<E>();
      ```
  
    - 처음 생성될 때에는 어떠한 링크도 만들어지지 않기 때문에 내부는 비어 있다고 보면 된다.
  
    - 끝부분에서부터 순차적으로 추가/삭제하는 경우는 ArrayList가 빠르지만 중간에 추가/삭제하는 경우에는 LinkedList가 더 빠르다.
  
      

### Set 컬렉션

- #### 특징

  - 수학의 집합에 비유
  - 저장 순서가 유지되지 않음

    - get() 메소드 없음
  - 객체 중복 저장 불가

  

- **Iterator** 메소드

  - Set 컬렉션은 인덱스로 객체를 검색해서 가져오는 메소드가 없어서 전체 객체를 대상으로 한번씩 가져오는 반복자를 제공한다.

    ```java
    Set<String> set = ...;
    Iterator<String> iterator = set.iterator(); 
    ```




- #### 구현 클래스

  - **HashSet**

    - 객체를 순서없이 저장

    - 동일 객체 및 동등 객체는 중복 저장하지 않음

    - 동등 객체 판단 방법

      - 객체 저장하기 전에 hashCode()를 호출해서 해시코드를 얻어내어 저장되어 있는 객체들의 
        해시코드와 비교하여 동일한지 판단한다.
      - 동일한 해시코드가 있다면 다시 equals() 메소드로 두 객체를 비교해서 true가 나오면 동일한 객체로 판단하고 중복 저장하지 않는다.
      
      ```java
      Set<E> set = new HashSet<E>();
      ```

    

  - 사용자 정의 클래스 중복 안 되게 저장

    - 사용자 정의 클래스에서 객체가 중복 저장되지 않게 하려면
      hashCode()와 equals() (둘 다) 재정의 해서 동등 객체가 될 조건을 정해야 함

    

  - LinkedHashSet

  - TreeSet



### Map 컬렉션

- #### 특징

  - 키와 값의 쌍으로 이루어진 Entry 객체를 저장하는 구조
  - 키와 값은 모두 객체
  - 키는 중복될 수 없지만 값은 중복 저장 가능

  

- #### 구현 클래스

  - **HashMap**

    - 키 타입은 String 많이 사용

    ``` java
    Map<K, V> map = new HashMap<K, V>(); // K : 키타입 V : 값타입
    
    map
    map.get(K); // 입력한 K값에 대한 V값을 가져옴
    ```

    

  - **HashTable**

    - 키 객체 만드는 법은 HashMap과 동일
    - Hashtable은 스레드 동기화가 된 상태
      - 여러개의 스레드가 동시에 Hashtable에 접근해서 객체를 추가,
        삭제하더라도 스레드에 안전
    - Hashtable은 멀티 스레드 환경에서 주로 사용
    - HashMap은 단일 스레드 환경에서 주로 사용
      - 동기화하면 객체 잠금이 발생해서 성능이 저하된다.

    

  - LinkedHashMap

  - TreeMap

  - Properties

    

### Collections 클래스 활용

- 컬렉션을 다루는 유용한 메소드 지원(static)
  - sort() : 정렬
  - reverse() : 역순으로 정렬
  - max() / min()

