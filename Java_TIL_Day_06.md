# Java_TIL_Day_06



- 목차 
  - 5장 참조 타입
    - 배열
      - 배열의 길이
      - 다차원 배열
      - 배열 복사
      - 향상된 for 문
    - 6장 클래스
      - 객체(Object)란?
      - 인스턴스 (instance)
      - 객체 생성
      - 메소드 (method)
      - 반환형 (return 문)
      - 메소드 호출





## 배열



### 배열의 길이

- 배열에 저장할 수 있는 전체 항목의 수 (배열 크기)

- 배열명.length

- 배열의 길이는 for문의 조건식에서 주로 사용

  ```java
  for(int i =0; i <num.length; i++) {  
  
  }
  ```

  

### 다차원 배열

- 2차원 이상의 배열

- 2차원 배열 예

  ```java
  int[ ][ ] a = new int[3][4]; // 행3개, 열4개
  ```

  

- 2차원 배열의 초기화

  - 배열을 선언할 때 값을 바로 저장
  - 선언 + 기억 장소 할당 + 원소에 값 저장을 한 번에 수행

  

- 2차원 배열의 크기
  배열의 크기 (원소의 개수) : length 속성

  ```java
  byte[ ][ ]  a = new byte[3][2]’
  a.length : 행의 개수 (3)
  a[0].length : 0행의 열의 개수 (2)
  a[1].length : 1행의 열의 개수 (2)
  a[2].length : 2행의 열의 개수 (2)
  ```

  

- 비정방형 배열

  - 각 행마다 열의 개수가 다른 배열

  - 즉, 메모리 할당 시 열의 개수를 정하지 않고

  - 동적으로 열의 개수 할당

    ``` java
    int[ ][ ] a = new int[4][ ]; // 열의 개수 정하지 않음
    a[0] = new int[1]; // 0행에 1개의 원소 생성
    a[1] = new int[2]; // 1행에 2개의 원소 생성
    a[2] = new int[2]; // 2행에 2개의 원소 생성
    a[3] = new int[4]; // 3행에 4개의 원소 생성
    ```

  - 비정방형 배열 초기화

    - 각 행마다 열의 개수를 다르게 값 설정

      ```java
      int[][] a = {{1}, {2, 3}, {4, 5, 6}};
      ```

- 주의

  - 배열의 index 범위를 벗어날 때 오류 발생
  - ArrayIndexOutOfBoundsException



### 배열 복사

- 배열은 한 번 생성하면 크기 변경 불가

- 더 많은 저장 공간이 필요하면 더 큰 배열을 새로 만들고 이전 배열로부터 항목 값들을 복사

  

- #### 배열 복사 방법

  - for문 사용해서 각 원소의 값을 하나씩 복사

  - System.arrayCopy() 메소드 이용

    ```java
    System.arrayCopy(원본배열, 시작인덱스, 대상배열, 시작인덱스, 복사할 항목 개수);
    ```

    

### 향상된 for 문

- 배열 및 컬렉션의 항목 요소를 순차적으로 처리

- 인덱스 이용하지 않고 바로 항목 요소 반복

  ```java
  for( 변수 : 배열 ){ … }; 
  
  ex)
  int[] scores = {95, 71, 84, 93, 87};
  int sum = 0;
  for(int score : scores){
      sum += score;
  }
  ```

  - 변수에 배열 항목 하나씩 저장해서 사용
  - 배열의 원소의 개수만큼 반복 수행



## 6장 클래스



- 클래스 : 사용자 정의 자료형

- 객체 : 객체를 통해서 클래스 사용

- 변수 : 데이터 

- 메소드 

  - 기능 (작업 : 변수를 사용해서 특정 작업 수행)

    ```java
    객체.메소드()
    ```



### 객체 지향 프로그래밍 

- OOP(Object Oriented Programming)
- 존재하는 모든 것을 객체로 표현
- 객체를 중심으로 생각
- 부품 객체를 먼저 만들고 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법
- 프로그램을 작성하는데 필요한 모든 요소를 사람들의 사고 방식과 
  비슷한 방법으로 모델링



### 객체(Object)란?

- 물리적으로 존재하는 것 (자동차, 책 사람, ….)
- 추상적인 것(회사, 날짜) 중에서 자신의 속성과 동작을 가지는 모든 것
- 객체는 필드(속성-데이터)와 메소드(동작-기능)로 구성된 자바 객체로 모델링 가능
- 객체를 생성하기 위해서는 클래스를 설계한 후 객체를 통해 
  필드와 메소드에 접근하여 작업 수행



### 객체 지향 프로그래밍 특징



- #### 캡슐화

  - 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
  - 외부 객체는 객체 내부 구조를 알지 못하며 객체가 노출해 제공하는 필드와 메소드만 이용 가능
  - 필드와 메소드를 캡슐화하여 보호하는 이유
    - 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 (데이터 보호 || 은닉)
  - 자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결정하기 위해 접근 제한 사용 (public / private, ….)

  

- #### 상속

  - 상위(부모) 객체의 필드와 메소드를 하위(자식) 객체에게 물려주는 행위
  - 하위 객체는 상위 객체를 확장해서 추가적인 필드와 메소드를 가질 수 있음
  - 상속의 효과
    - 코드 경제성 : 객체 재사용
    - 상위 객체를 재사용해서 하위 객체를 빨리 개발 가능
    - 반복된 코드의 중복 줄임
    - 유지 보수 편리
    - 객체의 다형성 구현

  

- #### 다형성

  - 같은 타입이지만 실행 결과가 다양한 객체를 대입할 수 있는 개념
  - 부모 타입에는 모든 자식 객체 대입
  - 인터페이스 타입에는 모든 구현 객체가 대입
  - 효과
    - 객체를 부품화시키는 것 가능
    - 유지보수 용이



### 클래스와 객체

- 클래스 : 제품 설계도 (객체를 만들어내는 틀)
- 사용자가 임의로 정의
- 사용자 정의 타입
- 객체 : 부품
- 클래스에는 객체를 생성하기 위해 필드와 메소드 정의



### 인스턴스 (instance)

- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 함

- 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있음

  

- 객체와 인스턴스

  - 객체 - 일반적인 용어
  - 인스턴스 - 특정 클래스의 객체 강조
  - 특정 시점의 객체



### 클래스의 이름

- 자바 식별자 작성 규칙에 따름
- 식별자 (구별지을 수 있는 것) : 변수, 클래스, 메소드
- 한글 이름도 가능하나 영어 이름으로 작성
- 알파벳 대소문자는 서로 다른 문자로 인식
- 첫 문자와 연결된 다른 단어의 첫 문자는 대문자로 작성하는 것이 관례
  (카멜 표기법)



### 객체 생성

- 객체 생성과 참조 변수

- 객체를 생성하기 전에 객체를 가리킬 참조 변수 필요

- 참조 변수 : 객체를 참조하는(가리키는) 변수

  ```java
  Car c;	// Car 클래스의 참조 변수 c 선언
  // 아직 객체 생성되지 않았음
  // 반드시 new 연산자를 사용하여 객체 생성
  c = new Car();    // Car 타입의 메모리 공간 확보
  
  // 참조 변수 선언과 동시에 객체 생성
  Car c = new Car();
  ```



### 객체 멤버에 접근

- 생성된 객체에 접근하여 사용

- 형식

  ```java
  참조변수(객체).멤버
  Car c = new Car();
  c.carName;     // 객체.멤버필드
  c.showCarInfo(); // 객체.멤버메소드()
  ```



### 메소드 (method)

- 객체의 동작(기능, 업무처리)

- 클래스 내에서 작업을 처리하는 단위

- 특정 기능을 수행하고 결과를 반환하는 독립적인 코드 집합

- 메소드에는 괄호를 붙임 : 메소드명()

- main()은 프로그램이 실행되면 맨 처음에 수행되는 메소드

- 클래스 내에서 작업을 분리하여 여러 메소드가 처리 (분업)

- 프로그램 재사용 (경제성)

- 필요한 곳에서 여러 번 호출하여 사용

- 상속 시 부모 클래스의 메소드와 멤버 필드 재사용

- 코드 작성 비용 단축 및 시스템 안정성 보장

- main() 메소드는 클래스의 실행만 담당

  

- 메소드 선언(정의) 형식

  - 메소드가 처리하는 작업을 정의하는 것

  - body { } 구현 포함

    ```java
    (접근 제어자) (반환형) (메소드명)(매개 변수 목록){
        처리 작업 
        return 문; // 반환값이 있는 경우
    }
    
    ex)
    public int sum(int x, int y){
        return x + y;
    }
    ```

    

### 접근 제어자

- 클래스 외부에서 메소드에 접근, 사용을 허용할지 제한할지를 정하기 위해 사용
- public / protected / private
- public : 완전 허용
- private : 완전 접근 금지
- protected : 일부 허용 (상속 받은 클래스만 허용)



### 반환형 (return 문)

- 메소드가 실행 후 결과값을 반환할 때 사용
- 반환값이 없는 경우 : void
  - 이 경우에는 메소드 안에 return 문 없음
- 반환되는 값의 유형과 일치하게 반환형 사용



### 메소드 호출

- 메소드를 사용하기 위해서는 메소드가 필요한 곳에서 호출(메소드명을 써주면 됨)
- 호출하지 않으면 메소드는 아무 일도 하지 않음
- 메소드 내에서 다른 메소드 호출 가능
