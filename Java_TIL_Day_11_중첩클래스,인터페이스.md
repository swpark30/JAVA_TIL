# Java TIL Day 11 (중첩 클래스,인터페이스)



- 목차
  - 8장 인터페이스
    - 구현 클래스 
    - 인터페이스 상속
    - 강제 타입 변환
  - 9장 중첩 클래스와 중첩 인터페이스
    - 중첩 클래스
    - 중첩 인터페이스
    - 익명 객체
    - 익명 구현 객체



## 8장 인터페이스



### 구현 클래스 

- #### 사용이유

  - 객체는 인터페이스에서 정의된 추상 메소드와 동일한 실체 메소드를 가지고 있어야 하기 때문에 구현 객체가 필요하다.

    

- #### 사용 방법

  ```java
  Public class 구현클래스명 implements 인터페이스명{
      // 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
  }
  ```

  - 구현클래스를 만들 때 인터페이스를 작성하면 자동으로 Overriding이 된다.



### 인터페이스 상속

- 인터페이스를 상속받아 클래스를 구현하면 부모 인터페이스들의 모든 추상 메소드를 구현해야 함

- 인터페이스 간 상속 가능

- 다중 상속 가능

  

- #### 사용 방법

  ```java
  public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2 {....}
  ```



### 자동 타입 변환

- 구현 클래스로부터 객체 생성 후 하위 및 상위 인터페이스 타입으로 변환 가능

  ```java
  - 하위인터페이스 변수 = new 구현클래스();
    상위인터페이스1 변수 = new 구현클래스();
    상위인터페이스2 변수 = new 구현클래스();
  ```

  

### 강제 타입 변환

- 인터페이스 타입으로 자동 타입 변환 후, 구현 클래스 타입으로 다시 변환

- 사용이유

  - 구현 클래스 타입에 선언된 다른 멤버 사용하기 위해

- 객체 타입 확인 : instanceof 연산자

  - 강제 타입 변환 전에 구현 클래스 타입 조사

  - 구현 객체가 인터페이스 타입으로 변환되어 있는 상태에서 가능

  - 사용이유

    - 어떤 구현 객체가 변환되어 있는지 알 수 없는 상태에서 무작정 변환할 경우, 변환 불가 타입이면 ClassCastException 예외 발생

  - 사용 방법

    ```java
    참조변수(객체) instanceof 타입(클래스명)
    ```

    - 왼쪽의 객체가 오른쪽 타입의 인스턴스이면 true 반환






## 9장 중첩 클래스와 중첩 인터페이스



### 중첩 클래스

- 클래스 내부에 선언한 클래스

- 중첩으로 사용하는 이유

  - 두 클래스의 멤버들을 서로 쉽게 접근할 수 있다.
  - 외부에게 불필요한 클래스를 감춰 코드의 복잡성을 줄인다.

- 선언 방법

  ```java
  class 클래스명{
      class 중첩클래스명{ }
  }
  ```



- #### 클래스 내부에 선언되는 위치에 따라 2가지로 분류

  - 멤버 클래스
    - 클래스의 멤버로서 선언되는 중첩 클래스
    - 클래스나 객체가 사용 중이면 언제든지 재사용 가능
  - 로컬 클래스
    - 메소드 내에서만 선언되는 중첩 클래스
    - 메소드 실행 시에만 사용되고 종료되면 없어짐



- #### 인스턴스 멤버 클래스

  - static 키워드 없이 선언된 클래스

  - 인스턴스 필드와 메소드만 선언가능, 정적 필드와 메소드는 선언 불가

  - 바깥 클래스의 모든 필드와 메소드에 접근 가능

  - 외부에서 중첩 클래스 객체 생성 방법

    ```java
    A a = new A(); // 상위 객체를 생성하고
    A.B b = a.new B(); // 중첩된 클래스 객체를 생성한다.
    
    b.field1 = 3;
    b.method1();
    ```

    

- #### 정적 멤버 클래스

  - static 키워드로 선언된 클래스

  - 모든 종류의 필드, 메소드 선언 가능

  - 바깥 클래스의 정적 필드와 메소드에만 접근 가능

  - 외부에서 중첩 클래스 객체 생성 방법

    ```java
    A.C c = new A.C();
    
    c.field1 = 3;
    c.method1();
    A.C.field2 = 3; // 정적 필드 사용
    A.C.method2(); // 정적 메소드 사용
    ```

    

- #### 로컬 클래스

  - 메소드 내에서 선언된 클래스

  - 메소드 내에서만 사용하기 때문에 접근 제한 및 static 필요 없음

  - 선언과 접근가능은 인스턴스 멤버 클래스와 동일

    - 메소드의 매개변수나 로컬 변수를 사용할 때는 매개변수나 로컬 변수가 수정되어 값이 변경되면 로컬 클래스에 복사해 둔 값과 달라지는 문제가 발생하므로 변경되지 않도록 final로 선언
      (자바 8부터는 final 선언 안해도 자동으로 적용됨)

  - 클래스 생성 방법

    ```java
    class A{
        void method1{
            class D{
            }
            B b = new B(); // 메소드 안에 객체 생성
        }
    }
    public static void main(String[] args) {
    	A a = new A();
        
        a.method1(); // 메인에서 메소드만 호출하면 메소드 내부에 생성한 객체 실행
    }
    ```




- #### 중첩 클래스에서 바깥 클래스 참조 얻기

  - this 키워드 사용

    ```java
    this.필드		// 중첩 클래스 내부의 필드를 참조
    this.메소드()	
    
    바깥클래스.this.필드	// 바깥 클래스의 필드를 참조
    바깥클래스.this.메소드()
    ```

    

### 중첩 인터페이스

- 클래스 내부에 선언된 인터페이스
- 주로 UI 프로그래밍에서 이벤트를 처리할 목적으로 많이 사용된다.
- 사용 이유
  - 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위해서 사용한다.

- 선언 방법

  ```java
  class 클래스명{
      interface 중첩인터페이스명{ }
  }
  ```





### 익명 객체

- #### 익명 자식 객체

  - 이벤트 처리 객체나 스레드 객체를 간편하게 생성할 목적으로 많이 사용한다.
  
  - 일반 클래스와 차이점은 생성자 생성 불가
  
  - 사용방법 
  
    ```java
    부모클래스 [필드 | 변수] = new 부모클래스(매개값, ...){
        // 필드
        // 메소드
        // 메소드 재정의
    }; // 하나의 실행문이므로 세미콜론을 반드시 붙여야 한다.
    ```
  
    
  




- #### 익명 구현 객체

  - 사용이유

    - 구현 클래스를 만들면 재사용할 수 있기에 편리하지만 일회성의 구현객체를 만들기 위해
      소스 파일을 만들고 클래스 선언 하는 것은 비효율적이기 때문이다.

  - 사용방법
  
    ```java
    인터페이스 변수 = new 인터페이스(){
      	//인터페이스에 선언된 추상 메소드의 실체 메소드 선언  
    };
    ```
  
    

